<h3>SYNOPSIS</h3>

<p>
Execution routines: stored routines managing dynamic query execution, iteration & evaluation.
<ul>
	<li><a href="eval.html">eval()</a>: Evaluates the queries generated by a given query.</li>
	<li><a href="exec.html">exec()</a>: Executes a given query or semicolon delimited list of queries.</li>
	<li><a href="exec_file.html">exec_file()</a>:Executes queries from given file, residing on server./li>
	<li><a href="exec_single.html">exec_single()</a>: Executes a given query.</li>
	<li><a href="foreach.html">foreach()</a>: </li>
	<li><a href="repeat_exec.html">repeat_exec()</a>: Repeatedly executes given query or queries until some condition holds.</li>
</ul>
</p>

<h3>DESCRIPTION</h3>
<p>
These featured routines allow for semi-scripting capabilities in MySQL. Looping through collections,
row sets, numbers, tables; repeating tasks until a given condition hold, or dynamically evaluating
queries. The execution routines simplify a DBA's maintenance work by providing with a simpler,
cleaner and more familiar syntax.
</p>
<p>
The majority of operations in these routines use dynamic queries, based on prepared statements.
Note that MySQL does not support invoking a prepared statement from within a prepared statement. 
This means you may wish to avoid calling on these routines using prepared statements code (some 
frameworks will, by default, invoke queries using prepared statements regardless of the query type).
</p>

<h3>EXAMPLES</h3>
<p>Use <i>foreach()</i> to convert <strong>sakila</strong> tables to InnoDB:
</p>
	<blockquote><pre>mysql&gt; call foreach(
	  'table in sakila', 
	  'ALTER TABLE ${schema}.${table} ENGINE=InnoDB ROW_FORMAT=COMPACT');
</pre></blockquote>

<p>Use <i>repeat_exec()</i> to delete huge amount of rows in smaller chunks, with sleeping interval:
</p>
	<blockquote><pre>mysql&gt; call repeat_exec(2, 
	  'DELETE FROM sakila.rental WHERE customer_id=7 ORDER BY rental_id LIMIT 1000', 
	  0);
</pre></blockquote>

<p>Use <i>eval()</i> to dynamically evaluate and execute generated queries; in this example, we
kill all processes running for over 20 seconds (NOTE: this is a very simplified example; 
you would usually want to avoid killing replication processes, SUPER processes and sleeping processes):
</p>
</p>
	<blockquote><pre>mysql&gt; call eval('SELECT CONCAT(\'KILL \',id) FROM INFORMATION_SCHEMA.PROCESSLIST WHERE TIME > 20');
</pre></blockquote>
