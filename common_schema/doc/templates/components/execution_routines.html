<h3>SYNOPSIS</h3>

<p>
Execution routines: stored routines managing dynamic query execution, iteration & evaluation.
<ul>
	<li><a href="eval.html">eval()</a>: Evaluates the queries generated by a given query.</li>
	<li><a href="exec.html">exec()</a>: Executes a given query or semicolon delimited list of queries.</li>
	<li><a href="exec_file.html">exec_file()</a>:Executes queries from given file, residing on server./li>
	<li><a href="exec_single.html">exec_single()</a>: Executes a given query.</li>
	<li><a href="foreach.html">foreach()</a>: </li>
	<li><a href="repeat_exec.html">repeat_exec()</a>: Repeatedly executes given query or queries until some condition holds.</li>
</ul>
</p>

<h3>EXAMPLES</h3>
<p>Use <i>foreach()</i> to convert <strong>sakila</strong> tables to InnoDB:
</p>
	<blockquote><pre>mysql&gt; call foreach(
	  'table in sakila', 
	  'ALTER TABLE ${schema}.${table} ENGINE=InnoDB ROW_FORMAT=COMPACT');
</pre></blockquote>

<p>Use <i>repeat_exec()</i> to delete huge amount of rows in smaller chunks, with sleeping interval:
</p>
	<blockquote><pre>mysql&gt; call repeat_exec(2, 
	  'DELETE FROM sakila.rental WHERE customer_id=7 ORDER BY rental_id LIMIT 1000', 
	  0);
</pre></blockquote>

<p>Use <i>eval()</i> to dynamically evaluate and execute generated queries; in this example, we
kill all processes running for over 20 seconds (NOTE: this is a very simplified example; 
you would usually want to avoid killing replication processes, SUPER processes and sleeping processes):
</p>
</p>
	<blockquote><pre>mysql&gt; call eval('SELECT CONCAT(\'KILL \',id) FROM INFORMATION_SCHEMA.PROCESSLIST WHERE TIME > 20');
</pre></blockquote>
