
<p>
QueryScript Variables: creation, assignment, expansion & cleanup
</p>

<h3>SYNOPSIS</h3>
<p>
<blockquote><pre>var $table_name;
set $table_name := 'rental';
SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = $table_name;
ALTER TABLE sakila.:$table_name ENGINE=InnoDB; 
</pre></blockquote>
</p>

<h3>DESCRIPTION</h3>
<p> 
In addition to supporting MySQL's 
<a href="http://dev.mysql.com/doc/refman/5.1/en/user-variables.html">user defined variables</a>,
QueryScript introduces script local variables, with controlled creation and cleanup, and
with supported in-place expansion.
</p>
<h4>Declaration, usage and cleanup</h4>
<p>
The following code declares, sets and reads local variables:
<blockquote><pre>var $x;
set $x := 3; 
while ($x > 0)
{
  var $y;
  set $y := CONCAT('Value of $x is: ', $x);
  SELECT $y AS msg;
  set $x := $x - 1;
}
</pre></blockquote>
The <strong>$x</strong> and <strong>$y</strong> variables behave much like a <i>user defined variable</i>. 
They can be assigned to, read from, used within a query. 
</p>
<p>
However, the following differentiates it from MySQL's user defined variables:
<ul>
	<li>Variables must be declared by the <a href="query_script_var.html">var</a> statement.</li>
	<li>At the point of declaration, they are known to be <strong>NULL</strong>.</li>
	<li>Local variables are only recognized within their scope (see following).</li>
	<li>Once a variable's scope terminates, the variable is reset to <strong>NULL</strong>.
	  In the above example, <strong>$y</strong> is being reset to null at the end of each
	  loop iteration.</li>
</ul>
MySQL's user defined variables, in contrast, retain their value throughout the session, or until they are
assigned a new one.
</p>
<p>
Variables can be declared at any point; they do not necessarily have to be declared at
the beginning of a block or script.
</p>
<p>
A <a href="query_script_foreach.html">foreach</a> loop also declares variables, where the <i>var</i> statement
is not required.
</p>
<p>
Variable names are case-sensitive.
</p>
<p>
Note: current implementation uses MySQL's user defined variables, using variable names which are
unique within the script and the session in which they are declared.
</p>

<h4>Visibility</h4>
<p>
A variable is only visible in the scope in which it is declared. In the above example,
<strong>$x</strong> is recognized throughout the script, but <strong>$y</strong> may
only be accessed from within the loop's block.
</p>
<p>
One may use the above facts to force both cleanup and hiding of variables, by creating 
sub-blocks of code:
<blockquote><pre>{
  var $x;
  set $x := 3;
}
-- $x is known to be cleared at this point, and will
-- not be recognized from this point and on.
{
  var $y;
  set $y := 'abc';
} 
-- $y is known to be cleared at this point, and will
-- not be recognized from this point and on.
</pre></blockquote>
</p>
<p>
It is not allowed to declare two variables of the same name in the same script, even if 
they are not visible to each other. Thus, it would be an error to re-declare <strong>$x</strong>
in the second block in the above example.
</p>

<a name="expansion"></a>
<h4>Expansion</h4>
<p>
A variable may be <i>expanded</i> in-place. <i>Expansion</i> means the variable is replaced with the constant value it holds.
Expansion allows the programmer to use variables where variables are not allowed. To illustrate, we must first look at the basics.
</p>

<p>
Consider the following code:
<blockquote><pre>
var $x;
set $x := 3;
SELECT $x, :$x;

+--------------------+---+
| @__qs_local_var_16 | 3 |
+--------------------+---+
|                  3 | 3 |
+--------------------+---+
</pre></blockquote>
The above is somewhat delicate: the <strong>$x</strong> variable is in fact implemented as a MySQL user defined variable 
called <strong>@__qs_local_var_16</strong>. It has the value of <strong>3</strong>. However, the <strong>:$x</strong> value is
the <i>expansion</i> of <strong>$x</strong>, and is <i>the constant <strong>3</strong></i> (as is evident from column's name).
</p>

<p>
Now consider cases where variables cannot be used, yet expansion allows for seamless script approach: 
<blockquote><pre>
set @n := 2;
var $x;
set $x := @n + 1;

-- An error: -- SELECT Name FROM world.City ORDER BY Population DESC LIMIT @n;
-- An error: -- SELECT Name FROM world.City ORDER BY Population DESC LIMIT $x;
-- 
-- A valid statement:
SELECT Name FROM world.City ORDER BY Population DESC LIMIT :$x;

+-----------------+
| Name            |
+-----------------+
| Mumbai (Bombay) |
| Seoul           |
| SÃ£o Paulo       |
+-----------------+
</pre></blockquote>

<p>
As another example, consider:
<blockquote><pre>
set @t := 'City';
var $tbl;
set $tbl := 'City';

-- An error: -- ALTER TABLE world.@t ENGINE=InnoDB;
-- An error: -- ALTER TABLE world.$tbl ENGINE=InnoDB;
-- 
-- A valid statement:
ALTER TABLE world.:$tbl ENGINE=InnoDB;
</pre></blockquote>
An <strong>ALTER TABLE</strong> does not accept variables for table names. However, when using <i>expansion</i>, the last statement
translates to <strong>ALTER TABLE world.City ENGINE=InnoDB;</strong> before being sent to MySQL.
</p>

<p>
<i>Expansion</i> occurs just before query execution. It is therefore possible to expand changing values, as follows:
<blockquote><pre>
foreach($t: {City, Country, CountryLanguage})
{
  ALTER TABLE world.:$t ENGINE=InnoDB;
}
</pre></blockquote>
</p>

<p>
At this moment, expansion only applies to <a href="query_script_statements.html">SQL statements</a>. They do not work for QueryScript statements,
nor for <a href="query_script_expressions.html">expressions</a>.

</p>

<h3>SEE ALSO</h3>
<a href="query_script_foreach.html">foreach</a>,
<a href="query_script_input.html">input</a>,
<a href="query_script_var.html">var</a>

<h3>AUTHOR</h3>
Shlomi Noach


